// Generated by LiveScript 1.2.0
(function(){
  var ref$, primitiveOnlyAttributes, eitherAttributes, all, getNodeAtPath, toString$ = {}.toString;
  ref$ = require('grasp-syntax-javascript'), primitiveOnlyAttributes = ref$.primitiveOnlyAttributes, eitherAttributes = ref$.eitherAttributes;
  all = require('prelude-ls').all;
  getNodeAtPath = require('./common').getNodeAtPath;
  function matchNode(results, query, node){
    var key, val, ref$;
    if (eq(node, query)) {
      results.push(node);
    }
    for (key in node) {
      val = node[key];
      if ((key !== 'loc' && key !== 'start' && key !== 'end') && ((ref$ = toString$.call(val).slice(8, -1)) === 'Object' || ref$ === 'Array')) {
        matchNode(results, query, val);
      }
    }
  }
  function eq(targetNode, selectorNode){
    var selectorNodeType, prop, len, targetLen, arrWildcardMatched, i, i$, len$, node, targetsLeft;
    selectorNodeType = toString$.call(selectorNode).slice(8, -1);
    if (selectorNode === targetNode) {
      return true;
    } else if (selectorNodeType !== toString$.call(targetNode).slice(8, -1)) {
      return false;
    } else if (selectorNodeType === 'Object') {
      if (selectorNode.type === 'Grasp') {
        return matchSpecial(targetNode, selectorNode);
      } else {
        for (prop in targetNode) {
          if (prop !== 'loc' && prop !== 'start' && prop !== 'end') {
            if (!eq(targetNode[prop], selectorNode[prop])) {
              return false;
            }
          }
        }
        return true;
      }
    } else if (selectorNodeType === 'Array') {
      len = selectorNode.length;
      targetLen = targetNode.length;
      arrWildcardMatched = false;
      i = 0;
      for (i$ = 0, len$ = selectorNode.length; i$ < len$; ++i$) {
        node = selectorNode[i$];
        if (matchArrayWildcard(node)) {
          if (i + 1 === len) {
            return true;
          } else {
            arrWildcardMatched = true;
            targetsLeft = len - i - 1;
            i = targetLen - targetsLeft;
          }
        } else {
          if (!eq(targetNode[i], node)) {
            return false;
          }
          i++;
        }
      }
      return arrWildcardMatched || len === targetLen;
    } else {
      return false;
    }
  }
  function matchSpecial(targetNode, selectorNode){
    var identMatch, attrMatch;
    switch (selectorNode.graspType) {
    case 'wildcard':
      return true;
    case 'node-type':
      return targetNode.type === selectorNode.value;
    case 'matches':
      return in$(targetNode.type, selectorNode.value);
    case 'literal':
      return targetNode.type === 'Literal' && toString$.call(targetNode.value).slice(8, -1) === selectorNode.value;
    case 'compound':
      identMatch = matchSpecial(targetNode, selectorNode.ident);
      attrMatch = all(matchAttr(targetNode), selectorNode.attrs);
      return identMatch && attrMatch;
    }
  }
  function matchArrayWildcard(node){
    var cleanNode;
    cleanNode = node.type === 'ExpressionStatement' ? node.expression : node;
    return cleanNode.type === 'Grasp' && cleanNode.graspType === 'array-wildcard';
  }
  function matchAttr(targetNode){
    return function(attr){
      var node, attrValue, lastPath, ref$;
      node = getNodeAtPath(targetNode, attr.path);
      if (node != null) {
        attrValue = attr.value;
        if (attrValue) {
          lastPath = (ref$ = attr.path)[ref$.length - 1];
          if (in$(lastPath, primitiveOnlyAttributes)) {
            return matchPrimitive(attr.op, node, attrValue);
          } else if (in$(lastPath, eitherAttributes)) {
            return matchEither(attr.op, node, attrValue);
          } else {
            return matchComplex(attr.op, node, attrValue);
          }
        } else {
          return true;
        }
      } else {
        return false;
      }
    };
  }
  function matchPrimitive(op, node, attrValue){
    if (op === '=') {
      return node === attrValue.value;
    } else {
      return node !== attrValue.value;
    }
  }
  function matchComplex(op, node, attrValue){
    if (op === '=') {
      return eq(node, attrValue);
    } else {
      return !eq(node, attrValue);
    }
  }
  function matchEither(op, node, attrValue){
    return matchPrimitive(op, node, attrValue) || matchComplex(op, node, attrValue);
  }
  module.exports = {
    matchNode: matchNode
  };
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);
